# MySQL重点知识



-----



### 三大范式

##### 第一范式

1. 每一列属性都是不可再分的属性
2. 两列属性相似或一样，尽量合并为属性一样的列，确保不产生冗余数据
3. 单一属性的列为基本数据类型构成
4. 设计出来的表都是简单的二维表

##### 第二范式

1. 满足第一范式
2. 要求实体的属性完全依赖于主关键字

##### 第三范式

1. 满足第一范式和第二范式
2. 要求数据库表中不包含已在其他表中包含的非主关键字信息，即数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系



> **范式化设计的好处在于，减少冗余，数据重复度低，更新操作快，内存占用小，而以此为代价也会产生缺点，如查询时表关联多，查询索引命中较少等问题**



-----



### 反范式化设计

1. 为了性能和读取效率而适当的违反对数据库设计范式的要求
2. 为了查询的性能，允许少量的冗余数据



> **反范式化设计的目的就是为了提高效率，查询时表关联较少，索引有更多的命中，所带来的缺点是更新操作慢，数据重复高，内存占用大等**



-----



### 数据分流

例如需要统计网页点击量，创建下表

**hits**

| 字段  | 说明   |
| ----- | ------ |
| id    | 网页ID |
| count | 点击量 |

那么对应点击量增加的情况，将会执行以下SQL

update  hits  set  count = count + 1  where  id = xxx;

这种情况下就会产生一个行锁，来锁定id为xxx的这么一条数据，如果有很多个用户点击，那么只能等待上次点击更新完毕之后，再去更新下一次更新，就造成了一种多并发单线程的场景，就会对效率产生影响，该表的可用性降低



设计表时采用槽的概念，设计数据分流

**hits**

| 字段  | 说明   |
| ----- | ------ |
| id    | 网页ID |
| count | 点击量 |
| slot  | 分槽   |

现在假如有三个槽，那么多个用户点击时，就会做分流处理，比如用网页ID对3取余，然后匹配到对应的槽中，那么现在并发量处理效率就是之前的三倍，表的可用性增加，并发处理量增加，效率增加

update  hits  set  count = count + 1  where  id = xxx  and  slot = 1;

update  hits  set  count = count + 1  where  id = xxx  and  slot = 2;

update  hits  set  count = count + 1  where  id = xxx  and  slot = 3;

这三条SQL可以一起执行且不会影响锁



-----



### 表设计



##### 整数类型

| 类型      | 占用字符 |
| --------- | -------- |
| tinyint   | 1        |
| smallint  | 2        |
| mediumint | 4        |
| int       | 8        |
| bigint    | 16       |



1. 选择整数类型时，尽量选择更小的，在底层计算是会提高CPU效率，越大的数据类型会占用更多的资源，从而降低效率

2. 如果此字段不会出现负数的情况，就可以勾选 无符号 选项，这样在计算是就不会计算复数的情况，而正数层面的长度会翻倍，从而提高效率

3. 如果此字段不能为Null，在Java层面定义Model时，属性要尽量对照数据库，设计为基本数据类型，因为基本数据类型不能为Null且有默认值

4. 如果可以为Null，则设计成基本数据类型的包装类，因为包装类可以为Null
5. 设计表时，选择的长度在插入时没有影响，int(1)和int(30)在插入数据时效率一致



##### 实数类型

| 类型    | 占用字符 |
| ------- | -------- |
| float   | 4        |
| double  | 8        |
| decimal | 65       |

decimal底层是字符，在计算机底层进行计算时，没有该数据类型，所以需要转换，从而影响效率，但是此数据类型可以保证数据的精度

float和double底层可以直接进行计算，效率较高，但是浮点数运算不能保证精度

有下面这一个场景，用到一个表，表中有实数类型字段，该表访问数据量特别大，需要用实数字段类型存储数据，既要保证效率，又保证数据的精度，请问该怎么设计？

可以直接使用整数类型，在存入之前，对数据进行乘法操作，使其变为整数，然后存入表中，这样做可以使其运算时不丢失精度，也不会影响效率



##### 字符串类型

| 类型    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| char    | 自定义，定长，没有记录长度                                   |
| varchar | 自定义，不定长，需要多1~2个字节记录字符串的长度              |
| blob    | 存储量大，需要1~4字节存储指针，指向外部的存储区域，二进制存储，没有字符集和排序规则，一般将大字段抽出去出来成一张子表，需要时关联子表进行查询，对索引不友好 |
| text    | 存储量大，需要1~4字节存储指针，指向外部的存储区域，有字符集和排序规则，一般将大字段抽出去出来成一张子表，需要时关联子表进行查询，对索引不友好 |
| enum    | 适用于多个重复的字符串场景，例如类型，错误编号等，使用枚举可以减少内存的占用 |
| set     |                                                              |



##### 日期类型

| 类型      | 说明                                  |
| --------- | ------------------------------------- |
| datetime  | 1001年 ~ 9999年，精确到秒，跟时区无关 |
| timestamp | 1970年 ~ 2038年，精确到秒，跟时区有关 |

Mysql时间类型只能精确到秒，如果时间需要更小的粒度，比如精确到毫秒，就可以参照浮点数的优化一样，转换为整数类型

一般情况下用datetime



##### 命名规则

1. 尽量不使用缩写
2. 必须使用小写字母或数字
3. 不能使用复数名词
4. 禁用关键字保留字
5. 索引命名



-----



### 索引



##### 定义

索引(Index)是帮助Mysql高效获取数据的一种数据结构



##### 索引类型

InnoDB存储引擎支持以下几种常见索引

1. B+树索引
2. 全文索引
3. 哈希索引

哈希索引：适合精确查找，范围查找效率低，无法排序，无法使用组合索引，会有hash冲突，所以数据库索引一般不用哈希索引



-----



### B+树索引



##### B树

一种平衡多叉树，分支会存储数据，叶子也存储数据，并且叶子中数据会经过排序



##### B+树

在B树的基础上，分支不存储数据，只存储索引指针，叶子存储数据，并且叶子之间会有指针指向下一片叶子，就相当于链表，标准的B+树的叶子是单向链表，Mysql底层做了优化，是双向链表，这样可以利于排序和范围查找



##### B*树

在B树的基础上，同层分支也做了指针指向下一个分支



-----



### 聚集索引/聚簇索引/主键索引

将表的主键用来构造一棵B+树，底层叶子节点为表主键，且包含了主键对应的整条表数据，如果表没有主键，将会用隐藏RowNum来当作主键，构建一个B+树



-----



### 二级索引/辅助索引



##### 说明

Mysql中的每张表都会去根据主键创建一个B+树，然后除了主键的其他索引，也会去创建一个B+树，所以一个表的B+树数量等于索引数量+1

这种除了主键索引之外的索引，叫做二级索引/辅助索引



##### 二级索引/辅助索引的B+树结构

索引列构建的B+树，叶子节点为索引列和数据，其中还包含了一个书签(bookmark)，书签包含索引列数据以及主键索引和主键数据

二级索引的叶子节点不包含此行的全部数据，因为如果二级索引的B+树像聚集索引一样包含了全部的列数据，那么在对表数据进行了增删改操作时，就需要修改聚集索引的B+树以及其他索引的B+树，性能就会大大下降



-----



### 回表



##### 说明

通过辅助索引获得主键，然后通过聚集索引来找到一个完整的行记录，这样的操作叫做回表

例如：select * from table where name = xxx;

此时name列有索引，会根据name列索引的B+树找到对应的叶子节点，再通过叶子节点中存储的主键指针，去聚集索引的B+树寻找，最终根据主键的指针找到对应的一整行记录并返回

在实际的SQL优化中应当尽量减少回表的次数，因为如果能通过二级索引直接找到对应数据，而不是需要再去通过主键指针去聚集索引的B+树再寻找然后返回，就可以提高效率，回表操作越多，效率越低



-----



### 全表扫描



##### 说明

全表扫描就是一条一条记录的遍历，直到表中的最后一条记录，在数据库中，对无索引的表进行查询一般称为全表扫描



##### 什么情况会进行全表扫描

1. 条件中使用了null
2. 使用or作为连接条件
3. 使用 [not] in 时
4. 使用 左like 做模糊查询时
5. 使用 != 或者 <> 时
6. 使用 count(*) 时
7. 使用参数作为条件时
8. 索引使用不当时



-----



### 复合索引/联合索引



##### 定义

定义多个字段，一起为一个索引，称为复合索引



##### 复合索引的B+树结构

由多个索引列组成的B+树，叶子接待你存储的时索引列和数据，同样有书签，存储了主键指针和数据，叶子节点的列会按照复合索引是放入的顺序，从左到右进行排序，相当于 order by 索引字段 的排序效果



##### 复合索引的应用场景

如果一个表中多个字段经常且一起查询时，将这几个列创建复合索引，将会大大提高效率，因为多个字段+主键可以只访问一次复合索引的B+树，就可以获取所需要的所有数据



##### 最佳左前缀法则

order表结构

| 字段名 | 类型    | 索引                     |
| ------ | ------- | ------------------------ |
| id     | int     | 主键索引                 |
| name   | varchar | （name,age,pos）复合索引 |
| age    | int     | （name,age,pos）复合索引 |
| pos    | varchar | （name,age,pos）复合索引 |

order表数据

| id   | name | age  | pos  |
| ---- | ---- | ---- | ---- |
| 1    | A    | 19   | 6    |
| 2    | B    | 18   | 7    |
| 3    | C    | 21   | 9    |
| 4    | D    | 20   | 8    |



select * from order where name = xxx;

此时走了name的索引



select * from order where name = xxx and age = xxx;

此时走了name+age的索引



select * from order where name = xxx and age = xxx and pos = xxx;

此时走了name+age+pos的索引



select * from order where age = xxx and pos = xxx;

此时没有走索引，全表扫描



select * from order where name = xxx and pos = xxx;

此时走了name的索引



得出最佳左前缀法则：带头大哥不能死，中间兄弟不能断

从复合索引左边开始，如果为(ABC)，那么会先查询A的索引，然后再查B索引，以此类推

如果查询的为A = x and C = x，由于中间断了，A索引查找完之后，不能走B索引，也不能跳过B索引直接走C索引，所以只走了A索引

如果查询的为B = x and C = x，由于只能从A索引开始，不能跳过走B索引，所以相当于没有走索引，所以全表扫描

使用联合主键时，应当尽量遵循最佳左前缀法则

联合主键可以减少索引的数量，同时减少B+树的数量，减少回表操作，可以提高效率，减少内存消耗



-----



### 热数据监控

Mysql会自动去监控热数据索引，即监控索引的查询，如果判断有必要为热点数据消耗资源，就会对创建该索引查询Key的Hash索引，因为Hash索引是根据哈希表一次就能找到对应数据，所以提高了效率

这种自适应Hash索引完全由Mysql控制，人为无法干预，只能开启或关闭

如果面试官问InnoDB除了B+树还用到了什么索引，答，Mysql底层会进行索引查询的热数据监控，会对热数据生成Hash索引

热数据监控只会监控 [ 1 = 1 ] [ in(1,2,3) ] [ 1=1 or 2=2 ] 这三种操作



-----



### 高性能的索引创建策略

1. 索引列的类型尽可能的小，一般应用于主键，因为其他索引的B+树也会去存储主键，所以类型越小效率越高
2. 索引的选择列要尽量做到不重复，不重复率越高则查询效率越高
3. 针对varchar，text，blob，等很长的字段，Mysql不支持索引他们的全部长度，需要建立前缀索引，前缀索引语法：alter table 表名 add 字段名 (column(前缀的数量))，无法用于order by 和 group by，也无法做索引覆盖
4. 只为经常做搜索，排序，分组的列创建索引
5. 

















