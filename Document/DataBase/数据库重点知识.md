# 数据库重点知识



-----



### 创建表

create table 表名 ( 字段名[列名]  数据类型 [约束]; );



-----



### 删除表

drop table 表名;



-----



### 增加表数据

insert into 表名(列名1,列名2,....) values(值1,值2,....);



-----



### 删除表数据

delete from 表名 where 判断条件;



-----



### 修改表数据

update 表明 set 字段1 = 更新值，字段二 = 更新值 where 判断条件;



-----



### 查询表字段

select 字段1,字段2 from 表名  where 条件1 [and/or 条件2...] group by 分组条件1,分组条件2... order by 排序条件1,排序条件2... ;



-----



### 约束

1. 主键约束：primary key
2. 唯一约束：unique
3. 检查约束：Check
4. 默认约束：default
5. 外键约束：foreign key



-----



### 索引



##### 创建索引

create index 索引名 on 表名(字段名);



##### 添加索引

alter table 表名 add constraint 约束ID 约束名(字段名);



-----



### 模糊查询

select * from table where 表字段1 [not] like "%A%";

select * from table where 表字段1 [not] like "A%";

select * from table where 表字段1 [not] like "%A";

select * from table where 表字段1 [not] like "_A";

select * from table where 表字段1 [not] like "A_";



-----



### 统计函数

count(字段名/*/1): 统计行总数

sum(字段名)：统计字段值总和

avg(字段名): 计算字段值的平均值

max(字段名)：获取该字段中的最大值

min(字段名)：获取该字段中的最小值



-----



### 数据去重

select distinct 需要去重的列 from 表名 where 筛选条件；



-----



### 数据排序

select 字段 from 表名 where 条件 
order by 排序字段1 asc/desc,排序字段2 asc/desc....

asc/desc：升序/降序，不写默认为升序



-----



### 数据分组

select 字段 from 表名 where 条件 group by having 条件; 

就是 select 后面的所有列中，没有使用聚合函数的列，必须出现在 group by 后面



-----



### 常用函数

concat(str1,str2,str3,...)：拼接合并字符串函数

length：获取长度

insert(str,index,index,str1)：截取字符串

lower(str)：将字符串转为小写

upper(str)：将字符串转为大写

trim(str)：去除字符串两边的空格

replace(str,str1,str2)：替换字符串中的字符

reverse：反转字符串

new/sysdate：返回当前系统日期和时间值

curdate/current_date：返回当前系统日期值

cortime/current_time：返回当前系统时间值

month(time)：获取指定日期中的月份

week(time)：获取指定日期是一年中的第几周

year(time)：获取年份，返回值范围是 1970〜2069

dayofyear(time)：获取指定曰期是一年中的第几天，返回值范围是1~366

dayofmonth(time)：获取指定日期是一个月中是第几天，返回值范围是1~31

case when then else end case ：case when



-----



### 子查询

select * from 表名 where 表字段1 in(select 表字段1 from 表名 where 条件)；



-----



### 表连接

内连接：select 字段 from 表1 inner join 表2 on 表1.字段 = 表2.字段;

左连接：select 字段 from 表1 left join 表2 on 表1.字段 = 表2.字段;

右连接：select 字段 from 表1 right join 表2 on 表1.字段 = 表2.字段;

全外连接：select 字段 from 表1 full join 表2 on 表1.字段 = 表2.字段;



inner join：展示两边都符合条件的行

left join：以左边的表为基础表，返回左表所有行，并展示符合条件所对应的右表的行，右表无符合条件的数据时，用Null填充

right join：以右边的表为基础表，返回左表所有行，并展示符合条件所对应的左表的行，左表无符合条件的数据时，用Null填充

full join：以两边的表为基础表，返回两个表所有行，并展示符合条件所对应的左右表的行，左右表无符合条件的数据时，用Null填充



-----



### 合并查询

select 字段 from 表1
union
select 字段 from 表2;



select 字段 from 表1
union all
select 字段 from 表2;



union：将查询出的两张表中的对应字段并合并成一个表和一个列并进行去重

union all：将查询出的两张表中的对应字段并合并成一个表和一个列，不进行去重



-----



### 视图

create [or replace] view 视图名称
as
select * from table where 条件;



1. 视图一般只用于查询操作，一般不对视图进行增删改操作
2. 视图可以限制对数据的访问，通过视图可以看到数据，一般不根据视图修改数据
3. 视图可以展示经过复杂SQL筛选后的数据，简化了操作，提高了数据可视性



-----



### 分页

select * from table where 条件1 LIMIT 1 OFFSET 10;



-----



### 函数方法



##### 创建函数

create function 函数名(

​	参数名1 数据类型,

​	参数名2 数据类型,

​	参数名3 数据类型,

​    ...

)

return 返回值类型

begin

​	declare 变量名 变量类型 [default 默认值];

​	set 变量名 = 值;

​	-- 逻辑代码

​	return 数据;

end;



##### 调用函数

var value = 函数名(参数列表);



##### 删除函数

drop function 函数名;



-----



### 存储过程



##### 创建存储过程

create procedure 存储过程名(

​    [in/out/inout] 参数名1 数据类型,

​    [in/out/inout] 参数名2 数据类型,

​	[in/out/inout] 参数名3 数据类型,

​    ...

)

begin

​	declare 变量名 变量类型 [default 默认值];

​	set 变量名 = 值;

​	-- 逻辑代码

end;



##### 调用存储过程

call 存储过程名(参数列表);


##### 删除存储过程

drop procedure 存储过程名;



-----



### 存储过程常用语句



##### 区块

[区块名:] begin

​	逻辑代码;

​	[leave 区块名;]

end [区块名];



##### if判断

if 条件1 then

​	逻辑代码;

elseif 条件1 then

​	逻辑代码;

else

​	逻辑代码;

end if;



##### while循环

[while名] while 条件 do

​	逻辑代码;

​	[leave while名;]

​	[iterate;]

end while [while名];



##### loop循环

[loop 名] loop 

​	逻辑代码;

​	[leave loop名;]

​	[iterate;]

end loop [loop 名];



##### repeat循环

[repeat名] repeat

​	逻辑代码;

​	[leave repeat名;]

​	[iterate;]

until 条件

end repeat [repeat名]；



##### 异常

declare 异常名 condition for sqlstate '错误码';

declare [continue/exit] handler for  异常名1,异常名2,...  逻辑代码;



> continue：执行逻辑代码，并继续执行区块之后的代码
>
> exit：执行逻辑代码，并终止当前区块运行
>
> 可以通过signal sqlstate '错误码' set message_text = "错误信息";手动抛出异常信息
>
> sqlstate的值不能是00开头，因为这代表成功
>
> condition语句必须出现在handler语句之前



------



### 序列



##### 创建序列表

create table sequence (

​	序列名称  varchar(50) not null, 

​	初始值 int(10) not null,   

​	步长 int(10) not null default 1,    

​	primary key (seq_name)

);



##### 添加序列

insert into 序列表名 values("序列名"，初始值，步长);



##### 创建查询序列当前值函数

create function currval(v_seq_name varchar(10))

returns int(10)

begin

​	declare in_val int;

​	select 序列值 into in_val  from 序列表 where 序列名 = v_seq_name;

​	return value;

end;



##### 创建获取序列下个值函数

create function nextval (v_seq_name varchar(50)) 

returns int(10) 

begin

​    update 序列表 set 序列值 = 序列值+ 步长 where 序列表= v_seq_name;

​	return currval(v_seq_name);

end;



> 序列一般用来做字段值自增，Mysql中只能主键增长，如果其他字段的值也需要自增长，就需要使用序列



-----



### 游标



##### 声明游标

declare 游标名  cursor for 查询语句;



##### 使用游标

fetch  游标名 into 变量1,变量2,...;



##### 打开游标

open 游标名;



##### 关闭游标

close 游标名;



> 游标在创建后不能修改其数据，游标只能从上往下按照顺序读取，游标只能定义在存储过程中
>
> 游标一般用于存储过程中



-----



### 触发器



##### 声明触发器

cerate trigger 触发器名

​	[before/after]	--触发时机

​	[insert/update/delete] 	--触发事件

no 表名

for each row

​	[begin]

​		[set 变量名 = new/old 字段名;]

​		SQL语句;

​	[end;]	



##### 删除触发器

drop trigger 触发器名;



> 如果before触发器执行失败，其中的SQL无法执行
>
> 如果触发触发器的SQL执行失败时，after触发器不会触发
>
> after触发器执行失败，SQL会回滚
>
> 对于insert操作，用 new 字段名 获取插入的数据
>
> 对于delete操作，用 old 字段名 获取要删除的数据
>
> 对于update操作，用 new 字段名 获取要更新的数据，用 old 字段名 获取被更新的数据
>
> 
>
> 触发器的应用场景如下
>
> 更新数据后，将更新时间，更新者，更新数据等操作行为记录在Log表中
>
> 在删除数据前，判断是否有关联数据，如果有，停止删除操作
>
> A表和B表关联，在A表删除数据后，更新B表中关联词条数据的数据



-----



 
