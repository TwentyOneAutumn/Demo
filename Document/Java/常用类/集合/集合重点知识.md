# 集合重点知识



-----



### 数据结构



##### 紧密结构

典型的紧密结构就是数组，数据之间是紧密相连的，可以直接通过下标快速找到对应数据，但是因为插入或删除元素会使之后的元素整体的前进或后移一位，所以紧密结构查询效率快，增删效率慢



##### 跳转结构

典型的跳转结构是链表，数据之间不一定相连，可能是一块在这一块在哪，第一个元素除了存储数据外，还存储下一个元素的地址，这样在进行增删时，只需要修改增删元素相邻的元素中存储的引用地址就可以了，不会影响其他元素，但是如果查询的话，就要按照链路，先查第一个元素，在查第二个元素，以此类推，直到找到对应数据，所以跳转结构增删快，查询慢



-----



### 数组

1. 数组一旦指定了长度，就不可更改了
2. 数组一旦声明了类型后，就只能存放单一类型的数据
3. 数组底层是紧密结构，所以查询快增删慢
4. 数组只能获取整个数组的长度，没有提供方法或属性来获取数组中存储元素的个数
5. 数组存储数据是有序，可重复的



> **因为数组的缺点，满足不了某些场景下数据的增删改查错操作的效率，所以诞生了集合**

 

-----



### Collection集合关系



![](..\img\集合关系图.png)



-----



### Collection常用方法

| 方法                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| void add(obj)                 | 添加数据，集合在调用add方法时如果存储的是基本数据类型，则会自动装箱为对应的包装类 |
| Collection addAll(Collection) | 将另一个集合中的数据添加到本集合中                           |
| void clear()                  | 清空集合中的元素                                             |
| boolean isEmpty()             | 判断集合是否为空                                             |
| boolean remove(obj)           | 删除集合中的元素                                             |
| boolean contains(obj)         | 判断集合是否包含元素                                         |
| Iterator iterator()           | 根据集合生成迭代器，hasNext()判断是否有下一个，next()获取下一个元素 |



### ArrayList

ArrayList底层是一个Object[] 类型的数组

在JDK1.8中，在调用构造器时，集合底层初始化是一个空数组，长度为0

在第一次调用add方法时， 底层会生成一个新的数组长度为10，然后将底层老数组的数据copyOf()到新数组中，然后把底层数组的引用从老数组变为新数组

当数据存储达到数组长度时，再调用add方法底层就会对数组进行扩容，扩容的新数组长度为老数组的1.5倍



### LinkedList

LinkedList底层是数组+链表

除了Collection接口通用的方法之外，还有一些基于链表结构的方法

| 方法                          | 说明                                                       |
| ----------------------------- | ---------------------------------------------------------- |
| boolean addFirst(obj)         | 将指定元素插入集合的开头                                   |
| boolean addLast(obj)          | 将指定元素插入集合的结尾                                   |
| Iterator descendingIterator() | 返回一个逆向迭代的迭代器                                   |
| obj element()                 | 获取但不移除集合中的第一个元素，如果集合为空则抛出异常     |
| obj getFirst()                | 返回集合的第一个元素，如果集合为空则抛出异常               |
| obj getLast()                 | 返回集合的最后一个元素，如果集合为空则抛出异常             |
| int indexOf(obj)              | 返回集合中首次出现指定元素的索引，如果没有该元素返回-1     |
| int lastIndexOf(obj)          | 返回集合中最后一次出现指定元素的索引，如果没有该元素返回-1 |
| boolean offer(obj)            | 将指定元素添加到集合的末尾                                 |
| boolean offerFirst(obj)       | 将指定元素添加到集合的开头                                 |
| boolean offerLast(obj)        | 将指定元素添加到集合的末尾                                 |
| obj peekFirst()               | 获取但不移除集合的第一个元素，如果集合为null则返回null     |
| obj peekLast()                | 获取但不移除集合的最后一个元素，如果集合为null则返回null   |
| obj poll()                    | 获取并移除集合的第一个元素，如果集合为null则返回null       |
| obj pollFirst()               | 获取并移除集合的第一个元素，如果集合为null则返回null       |
| obj pollLast()                | 获取并移除集合的最后一个元素，如果集合为null则返回null     |
| obj removeFirst()             | 获取并移除集合的第一个元素，元素不存在时抛出异常           |
| obj removeLast()              | 获取并移除集合的最后一个元素，元素不存在时抛出异常         |



通过indexOf获取LinkedList集合中指定下标的元素时，底层做了判断，会判断当前索引在集合的前半段还是后半段，如果在前半段就从前往后遍历，如果在后半段就从后往前遍历，这么做是为了提高LinkedList查询的效率



##### HashSet

HashSet中存入的元素无序且唯一

1. 调用add()存入元素
2. 底层调用hashCode()方法计算出当前元素的hashCode值
3. 根据计算的hashCode值得出在底层数组中对应的下标
4. 如果下标中没有元素，则直接存入
5. 如果下标中有元素，调用元素的equals()方法进行判断
6. 如果返回true，代表两个对象相等，则add()方法返回失败
7. 如果为false，代表两个对象相等，在数组当前索引位置延伸出一个链表，继续存放当前元素



所以根据上述流程得出结论

1. HashSet底层的结构为 数组 + 链表 = 哈希表
2. 存入的元素必须重写hashCode()和equals()方法，如果没有重写这两个方法则不能保证数据的唯一性
3. HashSet底层是用HashMap实现的，会把add()存入的值当作Key，在Value的位置填充一个Object类型的占位参数



##### LinkedHashSet

在HashSet的基础上，元素存入底层数组时，会有额外的链表结构，例如存入第一个元素，到存入的第二个元素之间有链表指针连接，可以做到按照元素存入的顺序进行输出，简单来说就是元素唯一，有序



##### TreeSet

底层使用的数据结构为二叉树，存入的元素使用比较器来判断元素在二叉树中的位置，所以TreeSet存储的元素必须实现Comparable接口，并重写compare()方法并在其中编写比较逻辑，返回int值

在new TreeSet()时可以传入外部比较器，此时TreeSet会按照外部比较器的规则来进行比较

底层通过TreeMap实现



### Map关系图

![](..\img\集合关系图2.png)



-----



### Map常用方法

| 方法                             | 说明                                                       |
| -------------------------------- | ---------------------------------------------------------- |
| value put(obj key,obj value)     | 添加一个键值对                                             |
| void putAll(Map map)             | 将Map中的所有键值对复制到当前Map中                         |
| value get(obj key)               | 获取集合中键对应的值，如果没有则返回null                   |
| void clear()                     | 清空集合                                                   |
| value remove(obj key)            | 如果存在该key，移除该键值对                                |
| boolean contalnsKey(obj key)     | 查询集合中是否存在该键                                     |
| boolean contalnsValue(obj value) | 查询集合中是否存在该值                                     |
| boolean isEmpty()                | 判断集合是否为空                                           |
| entrySet()                       | 将Map中每一个键值对转化为Entry对象并转换为Set＜Entry＞集合 |
| Set keySet()                     | 将Map中的所有Key，转化为Set集合                            |
| values()                         | 将Map中的所有Value，转化为Set集合                          |



-----



### HashMap

HashMap添加键值对时，底层的逻辑

1. 调用put()方法添加键值对
2. 计算Key的hashCode，并得出在底层数组中应该存放的下标位置
3. 将键，值，hashCode，下一个元素的地址封装为Node类对象
4. 将Entry类对象存入底层数组中hashCode对应的下标位置
5. 如果位置没有元素，则直接存放
6. 如果位置有元素，且Key值一样，则直接覆盖旧元素，存入新元素
7. 如果位置有元素，且Key值不一样，则形成链表结构，JDK1.7往链表头部位置添加，JDK1.8往链表尾部位置添加

##### HashMap重点知识

1. HashMap底层的数据结构为 数组(Node) + 链表(红黑树)
2. HashMap底层数组中某个链的长度大于8且底层数组长度或等于大于64，底层链表会变形为红黑树，如果链表长度大于8但数组长度小于64，则对数组进行扩容，如果数组中的键值对个数小于或等于6时，将会把红黑树结构还原为链表
3. 如果创建HashMap时，传入了一个int类型的长度，就会根据长度，进行位运算，最终计算出最接近该长度的2的N次幂的值，来作为数组长度，所以HashMap底层数组的长度永远是2的N次幂
4. 数组长度为2的N次幂时，在底层计算Key的hashCode所对应的在底层数组的下标位置时，可以减少哈希冲突的发生，同时在获取到Key的hashCode后，会对数组长度进行&操作，等效于对数组长度取余，等效的前提就是数组长度必须为2的N次幂，如果数组长度不是2的N次幂，则&操作不等效于取余，会增加哈希冲突的发生，取余之后的值就是当前键值对在底层数组中的索引位置
5. HashMap底层数组默认长度为16，在底层数组中元素的个数超过整个数组的四分之三且临界值的键值对不等于空的时候，会进行数组扩容，扩容为原本数组长度的两倍
6. 在获取Key的hashCode时，做了二次散列，扰动函数，去增加值的不确定性，减小哈希冲突的发生
7. HashMap内部的装填因子默认为0.75，如果高于0.75，空间利用率提高，但是很容产生哈希冲突，进而产生过多或过长的链表，导致查询效率降低，如果低于0.75，哈希冲突发生率降低，产生链表的几率降低，查询效率高，但是空间利用率太低了，占用内存，所以取了一个折中的值0.75
8. HashMap中允许一个唯一的Key为null值，如果存入多个Key为null但Value不一样的键值对，则后添加的覆盖之前的Value
9. HashMap实现了Cloneable接口和Serializable接口，因此可以被克隆和序列化



-----



### Hashtable

相比于HashMap效率低，但是线程安全，Key不可存null值

因为Hashtable线程安全，找不到Key的时候可以返回null值，找到则返回非空的Value，而且存入Hashtable的任何键值对都要去计算Key的hashCode，为null则不能计算



-----



### LinkedHashMap

在HashMap的基础上，元素存入底层数组时，会有额外的链表结构，例如存入第一个元素，到存入的第二个元素之间有链表指针连接，可以做到按照元素存入的顺序进行输出



-----



### TreeMap

1. 特点为唯一，有序(升序/降序)
2. 底层数据结构为二叉树，Key遵照二叉树的特点，所以TreeMap中Key的值必须实现比较器，同样的可以在new TreeMap()时传入外部比较器
3. TreeMap 实现了Cloneable接口和Serializable接口，因此可以被克隆和序列化
4. Key不可以为null，Value可以



-----





### 迭代器

迭代器是为了更方便的遍历集合，迭代器提供了一种方法来顺序访问一个聚合对象中的各个元素，而不保留该对象内部的元素，foreach循环底层使用的也是迭代器



##### cursor

因为Java中没有指针，所以迭代器内部用了cursor这个变量来模拟指针的效果，初始值为0



##### next()

获取集合中的元素，在此方法中声明了局部变量来接收cursor和elementDate，获取迭代器中当前的元素，并把cursor的值加1，然后根据cursor的值给lastRet变量赋值，然后返回lastRet下标位置的数据



##### hasNext()

判断cursor是否和size一样，如果一样证明集合中没有元素了，返回false，如果不相等，则证明集合中还有元素，返回true



-----

